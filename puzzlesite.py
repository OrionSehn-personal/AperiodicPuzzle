import streamlit as st  
import base64
from fibbonacciTimesFibbonacciSubstitution import *
from Bezier import * 
from write_to_svg import *
import plotly.express as px

def draw_svg(svg_file):
    with open(svg_file, 'r') as f:
        svg = f.read()
    b64 = base64.b64encode(svg.encode('utf-8')).decode("utf-8")
    html = r'<img src="data:image/svg+xml;base64,%s"/>' % b64
    st.write(html, unsafe_allow_html=True)

def bitwise_histogram(param_set):
    differences = hamming_set_difference(param_set)
    fig = px.histogram(differences, nbins=18, title="Hamming Distance Distribution", width=600, range_x=[0, 18])
    fig.update_layout(showlegend=False, bargap = 0.1, xaxis_title="Hamming Distance", yaxis_title="Number of Edges")
    st.text(f"{differences.describe()}")
    st.plotly_chart(fig)

def float_histogram(param_set):
    differences = manhattan_set_difference(param_set)
    fig = px.histogram(differences, nbins=18, title="L1 Distance Distribution", width=600, range_x=[0, 18])
    fig.update_layout(showlegend=False, bargap = 0.1, xaxis_title="L1 Distance", yaxis_title="Number of Edges")
    st.text(f"{differences.describe()}")
    st.plotly_chart(fig)

st.set_page_config(layout="wide")

st.title("Puzzle Generator") 
with st.expander("About"):
    st.markdown(
        r"""
        ## Introduction
        This project explores Bezier Curves, and their applications. In particular, applying restrictions to a set of Bezier Curves to generate jigsaw puzzles with non-standard bases. These non-standard bases come from Substitution Tilings. 
        
        The project is publically availible at: https://github.com/OrionSehn-personal/AperiodicPuzzle

        Please feel free to contact me at:
        orion.sehn@gmail.com

        Thank you to my supervisor, Dr Christopher Ramsay, and to Dr Adam Humeniuk for their help and support.
        ## Puzzle Edges
        """
    )
    st.markdown("""
    Puzzle Edges are generated by applying a set of restrictions to a set of Bezier Curves. 
    > For an introduction to Bezier Curves, see: https://pomax.github.io/bezierinfo/
    The Bezier Curves are connected at these control points {a, b, c, d, e, f, g, h, i}
    """)

    st.image("CurveDraft.jpg", width=600)

    st.markdown("""
    The limiting behaviour of these curves at the points follows some simple rules to ensure
    that they meet continuously. 

    
    - At point a, the limit of the derivatives of each curve is equal to 0.
    - At point b, the limit of the derivatives of each curve is equal to 0.
    - At point c, the limit of the derivatives of each curve is equal to infinity.
    - At point d, the limit of the derivatives of each curve is equal to infinity.
    - At point e, the limit of the derivatives of each curve is equal to 0.
    - At point f, the limit of the derivatives of each curve is equal to infinity.
    - At point g, the limit of the derivatives of each curve is equal to infinity.
    - At point h, the limit of the derivatives of each curve is equal to 0.
    - At point i, the limit of the derivatives of each curve is equal to 0.

    Additionally, the slope of the curve going from t0 to a, and from i to t1 must not be greater than 1, to ensure these sections do not cross when puzzle peices are corner to corner.

    These restrictions force a number of the control points to be set values once the control points are chosen.

    """)
    
    st.image("CurveExamine.jpg", width=600)

    st.markdown("""Each control point falls within a bounding box, which defines the maximum y and x values a control point can have. This bounding box is relative to the distance between t0 and t1, and scales smoothly. Because there are 9 control points, and an x and y component for each control point, this means that each curve can be represented by a 18 dimensional vector, each element of which is a float between 0 and 1. Because each component represents a single coordinate of an edge, the difference in these coordinates can can be used to measure the difference between two puzzle edges.

A "good" jigsaw puzzle is one where the edges of a puzzle are all different, and ideally as different as possible. This means that the total difference should be maximized, but each puzzle edge should be as different as possible from each other puzzle edge. 
    """)
    st.latex(r"""S = 
    \begin{bmatrix}
    1\\
    0\\
    0\\
    0\\
    0\\
    1\\
    0\\
    0\\
    0\\
    0\\
    1\\
    0\\
    0\\
    0\\
    0\\
    \end{bmatrix}
,         \begin{bmatrix}
    0\\
    0\\
    0\\
    0\\
    0\\
    1\\
    0\\
    0\\
    0\\
    0\\
    0\\
    0\\
    0\\
    0\\
    0\\
    \end{bmatrix}
,         \begin{bmatrix}
            1\\
    0\\
    0\\
    0\\
    0\\
    1\\
    0\\
    0\\
    1\\
    0\\
    0\\
    0\\
    0\\
    1\\
    0\\
    \end{bmatrix}
    , ...
    """)
    st.latex(r"""Maximize: \sum_{i, j} |v_i - v_j|""")
    st.markdown(r"""
    The generation functions used here are different attempts to generate a set of vectors that maximize this function, and therefore maximize puzzle edge uniquness.
    """)

    st.markdown("""## Aperiodic Tilings

This Jigsaw Puzzle Generation strategy works on any given tiling system (although there are issues with tiling systems that have angles which are quite sharp). Some novel tiling systems are used in this generator to make more interesting puzzles. Aperiodic tilings are type of Substitution Tiling which does not repeat with a period. They are created by starting with some inital tile, then substituting that tile with other tiles following a rule, then inflating those smaller tiles to be the origional size, then iterating that algorithm until you tile a sufficiently large region.
    """)

    cola, colb = st.columns([1, 1])
    with cola:
        st.image("rule.png", width=600, caption="Penrose Tiling Rule")
    with colb:
        st.image("patch (1).png", width=600, caption="Penrose Tiling")
    st.markdown("""
    
    for more images of aperiodic tilings, see: https://tilings.math.uni-bielefeld.de/
    
    """)
grid_types = ["Penrose", "Triangluar", "Square", "Custom"]
selected_grid = st.selectbox("Select Grid Type", options=grid_types)

st.markdown("""---""")

col1, col2 = st.columns([1.5, 1])

size = 650


with col2:
    gen_type = st.selectbox("Edge Generation Type", ["Binary Choice", "Uniform Random", "Random Binary", "Simplex Optimization"])

if gen_type == "Binary Choice":
    generator_func = bitwise_distribution
    show_distribution = float_histogram

elif gen_type == "Uniform Random":
    generator_func = random_distribution
    show_distribution = float_histogram

elif gen_type == "Random Binary":
    generator_func = random_unit_distribution
    show_distribution = float_histogram

elif gen_type == "Simplex Optimization":
    st.markdown("#Not yet implemented")

with col1:
    if selected_grid == "Penrose":

        iterations = st.number_input("Iterations", min_value=0, max_value=5, value=2)

        if iterations > 4:
            # st.warning("This may take a while")

            with st.spinner("Generating Puzzle - Warning: This may take a while"):
                penlines, border_list = penroseLines(iterations, maxradius=np.inf, init_scaling=0.2)
                svg_file = initialize_svg("puzzle.svg", size = size)
                param_set = generator_func(len(penlines))
                curveGen(penlines, param_set, flipTabs=True, svg_file=svg_file, size=size)
                draw_lines(border_list, svg_file, size=size)
                finalize_svg(svg_file)
                svg_file.close()

            draw_svg("puzzle.svg")

        else:
            with st.spinner("Generating Puzzle"):
                penlines, border_list = penroseLines(iterations, maxradius=np.inf)
                svg_file = initialize_svg("puzzle.svg", size = size)
                param_set = generator_func(len(penlines))
                curveGen(penlines, param_set, flipTabs=True, svg_file=svg_file, size=size)
                draw_lines(border_list, svg_file, size=size)
                finalize_svg(svg_file)
                svg_file.close()

            draw_svg("puzzle.svg")
    elif selected_grid == "Triangluar":
        with st.spinner("Generating Puzzle"):
            x = st.number_input("Triangles in x axis", min_value=0, max_value=15, value=10)
            y = st.number_input("Triangles in y axis", min_value=0, max_value=16, value=10)
            st.markdown(f"Number of Tiles: {x*y}")

            line_set, border_set = trigrid(x, y, translate= 7)
            svg_file = initialize_svg("puzzle.svg", size = size)
            param_set = generator_func(len(line_set))
            curveGen(line_set, generator_func(len(line_set)), flipTabs=True, svg_file=svg_file, size=size)
            for line in border_set:
                draw_line(line[0], line[1], svg_file, size=size)
            finalize_svg(svg_file)
            draw_svg("puzzle.svg")
            svg_file.close()



    elif selected_grid == "Square":

        x = st.number_input("Squares in x axis", min_value=0, max_value=30, value=10)
        y = st.number_input("Squares in y axis", min_value=0, max_value=30, value=10)
        st.markdown(f"Number of Tiles: {x*y}")

        if 0<x<17 and 0<y<17:
            line_set, border_set = recGrid(x, y, scaling = 0.6, translate=8)
            svg_file = initialize_svg("puzzle.svg", size = size)
            param_set = generator_func(len(line_set))
            curveGen(line_set, random_distribution(len(line_set)), flipTabs=True, svg_file=svg_file, size=size)
            for line in border_set:
                draw_line(line[0], line[1], svg_file, size=size)
            finalize_svg(svg_file)
            svg_file.close()
            draw_svg("puzzle.svg")
        elif 17<=x<=30 or 17<=y<=30:
            with st.spinner("Generating Puzzle"):
                line_set, border_set = recGrid(x, y, scaling=0.3, translate=16)
                svg_file = initialize_svg("puzzle.svg", size = size)
                param_set = generator_func(len(line_set))
                curveGen(line_set, random_distribution(len(line_set)), flipTabs=True, svg_file=svg_file, size=size)
                for line in border_set:
                    draw_line(line[0], line[1], svg_file, size=size)
                finalize_svg(svg_file)
                svg_file.close()
                draw_svg("puzzle.svg")

    elif selected_grid == "Custom":
        st.write("Make your own puzzle by uploading a list of edges, and a list of the borders.")

        edges = st.file_uploader("Puzzle Edges", type="svg")
        border = st.file_uploader("Puzzle Border", type="svg")


with col2: 
    st.markdown("---")
    with st.expander("Edge Generation Type Info"):
        if gen_type == "Binary Choice":
            st.markdown("### Binary Choice")
            st.markdown("Algorithm divides the edges in binary, then steps as much as possible by powers of two, to gaurentee unique edges. All components are either 0 or 1.")
        
        elif gen_type == "Uniform Random":
            st.markdown("### Uniform Random")
            st.markdown("Components are float values, components are randomly assigned a value between 0 and 1 using a uniform distribution.")
        
        elif gen_type == "Random Binary":
            st.markdown("### Random Binary")
            st.markdown("Each component is either 0 or 1, with equal probability.")
        
        elif gen_type == "Simplex Optimization":
            st.markdown("### Simplex Optimization")
            st.markdown("The Simplex Optimization algorithm attempts to find a distribution of edges that maximizes the hamming distance between edges. This is done by using a simplex optimization algorithm to find the distribution that minimizes the hamming distance between edges. This algorithm is not guaranteed to find the optimal distribution, but it is guaranteed to find a distribution that is close to optimal.")

        st.markdown("### Edges")
        st.markdown("Puzzle edges are represented as a set of 18 dimensional vectors. The components are either 0 or 1, or a float value between 0 and 1.")
        st.latex(r"""
        \begin{bmatrix}
        1\\
        0\\
        0\\
        0\\
        0\\
        1\\
        0\\
        0\\
        0\\
        0\\
        1\\
        0\\
        0\\
        0\\
        0\\
        \end{bmatrix}
,         \begin{bmatrix}
        0\\
        0\\
        0\\
        0\\
        0\\
        1\\
        0\\
        0\\
        0\\
        0\\
        0\\
        0\\
        0\\
        0\\
        0\\
        \end{bmatrix}
,         \begin{bmatrix}
                1\\
        0\\
        0\\
        0\\
        0\\
        1\\
        0\\
        0\\
        1\\
        0\\
        0\\
        0\\
        0\\
        1\\
        0\\
        \end{bmatrix}
        , ...
        """)
        st.markdown("These components represent the geometry of each of the individual curves. Puzzle edges with a greater hamming distance are more distinct, and thus selecting components to maximize their uniqueness is ideal.")


    with open("puzzle.svg", "rb") as file:
        btn = st.download_button(
                label="Download SVG",
                data=file,
                file_name="puzzle.svg",
                mime="image/svg+xml",
            ) 

    st.markdown("### Puzzle Edge Difference Statistics: ")
    st.markdown("Each edge has a vector representation, and the difference between two edges is the hamming distance between two vectors. The following statistics are calculated from the hamming differences between the edges in the puzzle.")
    with st.spinner("Calculating Statistics"):
        show_distribution(param_set)




    
# draw_svg("puzzle_sample.svg")
